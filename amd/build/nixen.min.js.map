{"version":3,"file":"nixen.min.js","sources":["../src/nixen.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * TODO describe module manager\n *\n * @module     customfield_sprogramme/manager\n * @copyright  2024 Bas Brands <bas@sonsbeekmedia.nl>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport State from 'customfield_sprogramme/local/state';\nimport Repository from 'customfield_sprogramme/local/repository';\nimport Notification from 'core/notification';\nimport {debounce} from 'core/utils';\nimport './local/components/table';\n\n\nclass Nixen {\n\n    /**\n     * Row number.\n     */\n    rowNumber = 0;\n\n    /**\n     * The dataset name.\n     */\n    dataset = 'columns_small';\n\n    /**\n     * Constructor.\n     * @return {void}\n     */\n    constructor() {\n        this.addEventListeners();\n        this.getDatagrid();\n    }\n\n    async getDatagrid() {\n        await this.getTableConfig();\n        await this.getTableData();\n    }\n\n    /**\n     * Get the table configuration.\n     * @return {Promise} The promise.\n     */\n    async getTableConfig() {\n        try {\n            const response = await Repository.getJsonData({filename: this.dataset});\n            // Validate the response, the response.date should be a string that can be parsed to a JSON object.\n            const json = this.parseResponse(response);\n            if (json) {\n                await State.setValue('columns', json);\n            } else {\n                Notification.exception('The response is not valid JSON');\n            }\n        } catch (error) {\n            Notification.exception(error);\n        }\n    }\n\n    /**\n     * Get the table data.\n     * @return {void}\n     */\n    async getTableData() {\n        try {\n            const response = await Repository.getData({dataset: this.dataset});\n            // Validate the response, the response.date should be a string that can be parsed to a JSON object.\n            const json = this.parseResponse(response);\n            if (json) {\n                State.setValue('rows', json);\n            } else {\n                const row = await this.createRow();\n                State.setValue('rows', [row]);\n                this.resetRowSortorder();\n            }\n        } catch (error) {\n            Notification.exception(error);\n        }\n    }\n\n    /**\n     * Get the row object that can be accepted by the webservice.\n     * @return {Array} The keys.\n     */\n    getRowObject() {\n        return {\n            'rows': {\n                'id': 'id',\n                'sortorder': 'sortorder',\n                'cells': {\n                    'type': 'type',\n                    'columnid': 'columnid',\n                    'value': 'value',\n                },\n            },\n        };\n    }\n\n    /**\n     * Clean the rows object.\n     * @param {Array} rows The rows.\n     * @return {Array} The cleaned rows.\n     */\n    cleanRows(rows) {\n        const rowObject = this.getRowObject();\n        const cleanedRows = rows.map(row => {\n            const cleanedRow = {};\n            Object.keys(rowObject.rows).forEach(key => {\n                cleanedRow[key] = row[key];\n            });\n            // Clean the cells.\n            cleanedRow.cells = row.cells.map(cell => {\n                const cleanedCell = {};\n                Object.keys(rowObject.rows.cells).forEach(key => {\n                    cleanedCell[key] = cell[key];\n                });\n                return cleanedCell;\n            });\n            return cleanedRow;\n        });\n        window.console.log(JSON.stringify(cleanedRows));\n        return cleanedRows;\n    }\n\n\n    /**\n     * Set the table data.\n     * @return {void}\n     */\n    async setTableData() {\n        const set = debounce(async() => {\n            try {\n                const rows = State.getValue('rows');\n                const response = await Repository.setData({dataset: this.dataset, rows: this.cleanRows(rows)});\n                if (!response) {\n                    Notification.exception('No response from the server');\n                }\n            } catch (error) {\n                Notification.exception('Error 2' + error);\n            }\n        }, 600);\n        set();\n    }\n\n    /**\n     * Create a new row.\n     * @return {Object} The row.\n     */\n    createRow() {\n        return new Promise((resolve) => {\n            this.rowNumber++;\n            const row = {};\n            row.id = this.rowNumber;\n            const columns = State.getValue('columns');\n            if (columns === undefined) {\n                resolve();\n                return;\n            }\n            // The copy the columns to the row and call them cells.\n            row.cells = columns.map(column => structuredClone(column));\n            // Set the correct types for the cells.\n            row.cells.forEach(cell => {\n                cell.edit = true;\n                cell.value = '';\n                cell[cell.type] = true;\n            });\n            resolve(row);\n        });\n    }\n\n    /**\n     * Reset the row sortorder values.\n     * @return {void}\n     */\n    resetRowSortorder() {\n        const rows = State.getValue('rows');\n        rows.forEach((row, index) => {\n            row.sortorder = index;\n        });\n        State.setValue('rows', rows);\n    }\n\n    /**\n     * Add event listeners.\n     * @return {void}\n     */\n    addEventListeners() {\n        document.addEventListener('click', (e) => {\n            let btn = e.target.closest('[data-action]');\n            if (btn) {\n                e.preventDefault();\n                this.actions(btn);\n            }\n        });\n        // Listen to all changes in the table.\n        document.addEventListener('change', (e) => {\n            const input = e.target.closest('[data-input]');\n            if (input) {\n                this.change(input);\n            }\n        });\n    }\n\n    /**\n     * Actions.\n     * @param {object} btn The button that was clicked.\n     */\n    actions(btn) {\n        if (btn.dataset.action === 'add') {\n            this.add(btn);\n        }\n        if (btn.dataset.action === 'edit') {\n            this.edit(btn);\n        }\n        if (btn.dataset.action === 'save') {\n            this.save();\n            this.stopEdit();\n        }\n        if (btn.dataset.action === 'delete') {\n            this.delete(btn);\n        }\n\n        this.setTableData();\n    }\n\n    /**\n     * Change.\n     * @param {object} input The input that was changed.\n     */\n    change(input) {\n        const row = input.closest('[data-row]');\n        const cell = input.closest('[data-cell]');\n        const value = input.value;\n        const columnid = cell.dataset.columnid;\n        const index = row.dataset.index;\n        const rows = State.getValue('rows');\n        // Find the correct cell in the row.\n        const rowIndex = rows.findIndex(r => r.id == index);\n        const cellIndex = rows[rowIndex].cells.findIndex(c => c.columnid == columnid);\n        rows[rowIndex].cells[cellIndex].value = value;\n        this.setTableData();\n    }\n\n    /**\n     * Inject a new row after this row.\n     * @param {object} btn The button that was clicked.\n     */\n    async add(btn) {\n        const rows = State.getValue('rows');\n        // Find the rowcount this button is in the table.\n        const tablerows = document.querySelectorAll('[data-region=\"rows\"] [data-row]');\n        const index = Array.from(tablerows).indexOf(btn.closest('[data-row]'));\n        const row = await this.createRow();\n        rows.splice(index + 1, 0, row);\n        this.resetRowSortorder();\n        State.setValue('rows', rows);\n    }\n\n    /**\n     * Parse response data to a JSON object.\n     * @param {Object} response The response.\n     * @return {Any} The JSON object.\n     */\n    parseResponse(response) {\n        if (typeof response.data !== 'string') {\n            return;\n        }\n        try {\n            const Json = JSON.parse(response.data);\n            return Json;\n        } catch (error) {\n            return;\n        }\n    }\n}\n\n/*\n * Initialise\n *\n */\nconst init = () => {\n    new Nixen();\n};\n\nexport default {\n    init: init,\n};"],"names":["Nixen","constructor","addEventListeners","getDatagrid","this","getTableConfig","getTableData","response","Repository","getJsonData","filename","dataset","json","parseResponse","State","setValue","exception","error","getData","row","createRow","resetRowSortorder","getRowObject","cleanRows","rows","rowObject","cleanedRows","map","cleanedRow","Object","keys","forEach","key","cells","cell","cleanedCell","window","console","log","JSON","stringify","async","getValue","setData","set","Promise","resolve","rowNumber","id","columns","undefined","column","structuredClone","edit","value","type","index","sortorder","document","addEventListener","e","btn","target","closest","preventDefault","actions","input","change","action","add","save","stopEdit","delete","setTableData","columnid","rowIndex","findIndex","r","cellIndex","c","tablerows","querySelectorAll","Array","from","indexOf","splice","data","parse","init"],"mappings":"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"}