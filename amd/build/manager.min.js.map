{"version":3,"file":"manager.min.js","sources":["../src/manager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * TODO describe module manager\n *\n * @module     customfield_sprogramme/manager\n * @copyright  2024 Bas Brands <bas@sonsbeekmedia.nl>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport State from 'customfield_sprogramme/local/state';\nimport Repository from 'customfield_sprogramme/local/repository';\nimport Notification from 'core/notification';\nimport {getStrings} from 'core/str';\nimport {debounce} from 'core/utils';\nimport componentInit from './local/components/table';\nimport Pending from 'core/pending'; // For Behat to make sure that async calls are finished.\nimport './tagmanager';\nimport './programme_form';\n\n/**\n * Manager class.\n * @class\n */\nclass Manager {\n\n    /**\n     * Row number.\n     */\n    rowNumber = 0;\n\n    /**\n     * Module number.\n     */\n    moduleNumber = 0;\n\n    /**\n     * The datafieldid.\n     * @type {Number}\n     */\n    datafieldid;\n\n    /**\n     * The element.\n     * @type {HTMLElement}\n     */\n    element;\n\n    /**\n     * The table name.\n     */\n    table = 'customfield_sprogramme';\n\n    /**\n     * The table columns.\n     * @type {Array}\n     */\n    columns = [];\n\n    /**\n     * Constructor.\n     * @param {HTMLElement} element The element.\n     * @param {String} datafieldid The datafieldid.\n     * @return {void}\n     */\n    constructor(element, datafieldid) {\n        this.element = element;\n        this.datafieldid = parseInt(datafieldid);\n        this.addEventListeners();\n        this.getTableData();\n    }\n\n    /**\n     * Add event listeners.\n     * @return {void}\n     */\n    addEventListeners() {\n        document.addEventListener('click', (e) => {\n            let btn = e.target.closest('.modal-customfield_sprogramme_editor [data-action]');\n            if (btn) {\n                e.preventDefault();\n                this.actions(btn.dataset.action, btn);\n            }\n\n        });\n        // Listen to all changes in the table.\n        const form = document.querySelector('[data-region=\"app\"]');\n        form.addEventListener('change', (e) => {\n            const input = e.target.closest('[data-input=\"auto\"]');\n            if (input) {\n                this.change(input);\n            }\n            const modulename = e.target.closest('[data-region=\"modulename\"]');\n            if (modulename) {\n                this.changeModule(modulename);\n            }\n        });\n        // Resize the textareas when needed.\n        document.addEventListener('input', function(e) {\n            if (e.target.tagName === 'TEXTAREA') {\n                const textarea = e.target;\n                // Resize the textarea to fit the content.\n                textarea.style.height = 'auto'; // Reset height to auto to shrink if needed.\n                textarea.style.height = `${textarea.scrollHeight + 1}px`; // Set height to scrollHeight to fit content.\n                textarea.dataset.height = textarea.scrollHeight + 1; // Store the height in a data attribute.\n            }\n        });\n        // Listen to the arrow down and up keys to navigate to the next or previous row.\n        form.addEventListener('keydown', (e) => {\n            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {\n                this.navigate(e);\n                e.preventDefault();\n            }\n        });\n        form.addEventListener('submit', (e) => {\n            e.preventDefault();\n        });\n\n        let dragging = null;\n\n        form.addEventListener('dragstart', (e) => {\n            const handle = e.target.closest('[data-region=\"dragicon\"]');\n            if (!handle) {\n                e.preventDefault();\n                return;\n            }\n            dragging = handle.closest('tr');\n            e.dataTransfer.effectAllowed = 'move';\n        });\n        form.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            const target = e.target.closest('tr');\n            if (target && target !== dragging && target.parentNode.dataset.region === 'rows') {\n                const rect = target.getBoundingClientRect();\n                if (e.clientY - rect.top > rect.height / 2) {\n                    target.parentNode.insertBefore(dragging, target.nextSibling);\n                } else {\n                    target.parentNode.insertBefore(dragging, target);\n                }\n            }\n        });\n        form.addEventListener(\"drop\", (e) => {\n            e.preventDefault(); // Voorkom standaard drop-actie\n        });\n        form.addEventListener('dragend', (e) => {\n            const rowId = dragging.dataset.index;\n            const prevRowId = dragging.previousElementSibling ? dragging.previousElementSibling.dataset.index : 0;\n            const moduleId = dragging.closest('[data-region=\"module\"]').dataset.id;\n            this.moveRow(parseInt(moduleId), parseInt(rowId), prevRowId ? parseInt(prevRowId) : null);\n            dragging = null;\n            e.preventDefault(); // Voorkom standaard drop-actie\n        });\n    }\n\n    /**\n     * Get the table data.\n     * @return {void}\n     */\n    async getTableData() {\n        try {\n            const response = await Repository.getData({datafieldid: this.datafieldid, showrfc: 1});\n            if (response.modules.length > 0) {\n                const modules = this.parseModules(response);\n                const columns = response.columns;\n\n                State.setValue('columns', [...columns]);\n                State.setValue('modules', modules);\n                State.setValue('rfc', response.rfc ?? []);\n                State.setValue('editbuttons', {datafieldid: this.datafieldid, canedit: response.canedit});\n                this.sumtotals();\n            } else {\n                const response = await Repository.getColumns({datafieldid: this.datafieldid});\n                const columns = response.columns;\n                State.setValue('columns', [...columns]);\n                State.setValue('modules', []);\n                State.setValue('rfc', []);\n                State.setValue('editbuttons', {datafieldid: this.datafieldid, canedit: response.canedit});\n                this.addModule();\n            }\n        } catch (error) {\n            Notification.exception(error);\n        }\n    }\n\n    /**\n     * Parse the response, add the correct column properties to each cell.\n     * @param {Array} response The response.\n     * @return {Array} The parsed rows.\n     */\n    parseModules(response) {\n        response.modules.forEach(mod => {\n            mod.editor = response.canedit;\n            mod.rows.map(row => {\n                row.cells = row.cells.map(cell => {\n                    const column = response.columns.find(column => column.column == cell.column);\n                    // Clone the column properties to the cell but keep the cell properties.\n                    cell = Object.assign({}, cell, column);\n                    if (cell.type === 'select') {\n                        // Clone the options array to avoid shared references.\n                        cell.options = cell.options.map(option => {\n                            const clonedOption = Object.assign({}, option);\n                            if (clonedOption.name == cell.value) {\n                                clonedOption.selected = true;\n                            }\n                            return clonedOption;\n                        });\n                    }\n                    cell.changed = cell.value !== cell.oldvalue;\n                    return cell;\n                });\n                return row;\n            });\n        });\n        return response.modules;\n    }\n\n    /**\n     * Get the row object that can be accepted by the webservice.\n     * @return {Array} The keys.\n     */\n    getRowObject() {\n        return {\n            'rows': {\n                'id': 'id',\n                'sortorder': 'sortorder',\n                'deleted': 'false',\n                'todelete': 'false',\n                'cells': {\n                    'type': 'type',\n                    'column': 'column',\n                    'value': 'value',\n                    'group': 'group',\n                    'oldvalue': 'oldvalue',\n                },\n                'disciplines': {\n                    'id': 'id',\n                    'name': 'name',\n                    'percentage': 'percentage',\n                },\n                'competencies': {\n                    'id': 'id',\n                    'name': 'name',\n                    'percentage': 'percentage',\n                },\n            },\n        };\n    }\n\n    /**\n     * Check the cell value. It can not exceed the cell length.\n     * @param {object} cell The cell.\n     * @return {void}\n     */\n    checkCellValue(cell) {\n        if (cell.value === null) {\n            return;\n        }\n        if (cell.type === 'text' && cell.value.length > cell.length) {\n            cell.value = cell.value.substring(0, cell.length);\n        }\n    }\n\n    /**\n     * Clean a single cell.\n     * @param {object} cell The cell to clean.\n     * @param {Array} cellKeys The keys to keep in the cell.\n     */\n    cleanCell(cell, cellKeys) {\n        const cleaned = {};\n        this.checkCellValue(cell);\n        cellKeys.forEach(key => {\n            cleaned[key] = cell[key];\n        });\n        return cleaned;\n    }\n\n    /**\n     * Clean a list of objects based on allowed keys.\n     * @param {Array} items The items to clean.\n     * @param {Array} allowedKeys The keys to keep in the items.\n     */\n    cleanList(items, allowedKeys) {\n        return items.map(item => {\n            const cleaned = {};\n            allowedKeys.forEach(key => {\n                cleaned[key] = item[key];\n            });\n            return cleaned;\n        });\n    }\n\n    /**\n     * Validate the modules.\n     * @return {boolean} True if the modules are valid.\n     */\n    validateModules() {\n        const modules = State.getValue('modules');\n        let result = true;\n        if (modules.length === 0) {\n            result = false;\n            return result;\n        }\n        modules.forEach(module => {\n            if (!module.modulename || module.modulename.trim() === '') {\n                module.error = true;\n            }\n            module.rows.forEach(row => {\n                if (row.deleted) {\n                    return; // Skip deleted rows.\n                }\n                if (row.cells.length === 0) {\n                    row.error = true;\n                    result = false;\n                } else {\n                    if (!this.checkRow(row)) {\n                        result = false;\n                    }\n                }\n            });\n        });\n        State.setValue('modules', modules);\n        return result;\n    }\n\n    /**\n     * Check the row, if there are grouped cells, only one can have a value. and one should have a value.\n     * @param {Object} row The row to check.\n     * @return {boolean} True if the row is valid.\n     */\n    checkRow(row) {\n        const groups = {};\n        let result = true;\n        row.cells.forEach(cell => {\n            if (cell.group) {\n                if (!groups[cell.group]) {\n                    groups[cell.group] = [];\n                }\n                if (cell.value && cell.value > 0) {\n                    groups[cell.group].push(cell);\n                }\n            }\n        });\n        Object.keys(groups).forEach(group => {\n            if (groups[group].length > 1) {\n                // More than one cell in the group has a value.\n                groups[group].forEach(cell => {\n                    cell.error = true;\n                });\n                row.error = true;\n                result = false;\n            } else if (groups[group].length === 0) {\n                // No cell in the group has a value.\n                row.error = true;\n                result = false;\n            } else {\n                row.error = false;\n                row.error = false;\n            }\n        });\n        return result;\n    }\n\n\n    /**\n     * Clean the Modules array.\n     * @param {Array} modules The modules.\n     * @return {Array} The cleaned modules.\n     */\n    cleanModules(modules) {\n        const rowSpec = this.getRowObject().rows;\n\n        return modules.map(module => {\n            const cleanedModule = {\n                moduleid: module.moduleid,\n                modulename: module.modulename,\n                modulesortorder: module.modulesortorder,\n                deleted: module.deleted || false,\n                rows: module.rows.map(row => {\n                    const cleanedRow = {\n                        id: row.id,\n                        sortorder: row.sortorder,\n                        deleted: row.deleted || false,\n                        cells: this.cleanList(row.cells, Object.keys(rowSpec.cells)),\n                        disciplines: this.cleanList(row.disciplines, Object.keys(rowSpec.disciplines)),\n                        competencies: this.cleanList(row.competencies, Object.keys(rowSpec.competencies)),\n                    };\n                    return cleanedRow;\n                }),\n            };\n            return cleanedModule;\n        });\n    }\n\n    /**\n     * Set the table data.\n     * @return {void}\n     */\n    async setTableData() {\n        const pending = new Pending('customfield_sprogramme/manager:setTableData');\n        const set = debounce(async() => {\n            const saveConfirmButton = document.querySelector('[data-action=\"saveconfirm\"]');\n            saveConfirmButton.classList.add('saving');\n            if (!this.validateModules()) {\n                pending.resolve();\n                return '';\n            }\n            const modules = State.getValue('modules');\n            const cleanedModules = this.cleanModules(modules);\n            const response = await Repository.setData({datafieldid: this.datafieldid, modules: cleanedModules});\n            if (!response) {\n                Notification.exception('No response from the server');\n            } else {\n                await this.getTableData();\n                const update = await Repository.getData({datafieldid: this.datafieldid, showrfc: 0});\n                const modulesStatic = this.parseModules(update);\n                State.setValue('modulesstatic', modulesStatic);\n            }\n            pending.resolve();\n            setTimeout(() => {\n                saveConfirmButton.classList.remove('saving');\n            }, 200);\n        }, 600);\n        set();\n    }\n\n    /**\n     * Actions.\n     * @param {string} action The button that was clicked.\n     * @param {HTMLElement|null} element The element that was clicked.\n     */\n    actions(action, element) {\n        const actionMap = {\n            'addrow': this.addRow,\n            'deleterow': this.deleteRow,\n            'addmodule': this.addModule,\n            'deletemodule': this.deleteModule,\n            'saveconfirm': this.setTableData,\n            'showchanges': this.showchanges,\n            'closechanges': this.closeChanges,\n            'acceptrfc': this.acceptRfc,\n            'rejectrfc': this.rejectRfc,\n            'submitrfc': this.submitRfc,\n            'cancelrfc': this.cancelRfc,\n            'removerfc': this.removeRfc,\n            'resetrfc': this.resetRfc,\n            'closeform': this.closeForm,\n            'hide': this.closeForm,\n            'downloadcsv': this.downloadCsv,\n            'augmenttable': this.augmentTable,\n        };\n        if (actionMap[action]) {\n            actionMap[action].call(this, element);\n        }\n    }\n\n    /**\n     * Inject a new row after this row.\n     * @param {object} btn The button that was clicked.\n     */\n    async addRow(btn) {\n        const modules = State.getValue('modules');\n\n        let rowid = btn.dataset.id;\n        const moduleid = btn.closest('[data-region=\"module\"]').dataset.id;\n        const module = modules.find(m => m.moduleid == moduleid);\n        const rows = module.rows;\n        // When called from the link under the table, the rowid is not set.\n        if (rowid == -1) {\n            rowid = rows[rows.length - 1].id;\n        }\n\n        const row = await this.createRow();\n        if (!row) {\n            return;\n        }\n        // Inject the row after the clicked row.\n        rows.splice(rows.indexOf(rows.find(r => r.id == rowid)) + 1, 0, row);\n        this.resetRowSortorder();\n        State.setValue('modules', modules);\n    }\n\n    /**\n     * Create a new row.\n     *\n     * @return {Object} The row object.\n     */\n     createRow() {\n        const row = {};\n        this.rowNumber = this.rowNumber - 1;\n        row.id = this.rowNumber;\n        const columns = State.getValue('columns');\n        // The copy the columns to the row and call them cells.\n        row.cells = columns.map(column => structuredClone(column));\n        // Set the correct types for the cells.\n        row.cells.forEach(cell => {\n            cell.isnewcell = true;\n            cell.value = null;\n            cell[cell.type] = true;\n            cell.oldvalue = null;\n            cell.changed = false;\n        });\n        row.disciplines = [];\n        row.competencies = [];\n        return row;\n    }\n\n    /**\n     * Delete a row.\n     * @param {Object} btn The button that was clicked.\n     * @return {Promise} The promise.\n     */\n    async deleteRow(btn) {\n        const modules = State.getValue('modules');\n        const rowid = parseInt(btn.closest('[data-row]').dataset.index);\n        const moduleid = parseInt(btn.closest('[data-region=\"module\"]').dataset.id);\n        const modulefound = modules.find(m => m.moduleid == moduleid);\n        if (modulefound.rows.length > 0) {\n            // Find the row in the module.\n            const rowIndex = modulefound.rows.findIndex(r => r.id == rowid);\n            if (rowIndex !== -1) {\n                // Add the deleted attribute to the row.\n                if (rowid > 0) {\n                    modulefound.rows[rowIndex].deleted = true;\n                    // Set the changed attribute to each cell in the row.\n                    modulefound.rows[rowIndex].cells.forEach(cell => {\n                        if (cell.value !== null && (cell.type == 'float' || cell.type == 'number')) {\n                            cell.changed = true;\n                            cell.value = null; // Clear the value.\n                        }\n                    });\n                } else {\n                    // Remove the row from the module.\n                    modulefound.rows.splice(rowIndex, 1);\n                }\n                State.setValue('modules', modules);\n            } else {\n                Notification.exception('Row not found');\n            }\n        }\n        this.sumtotals();\n    }\n\n    /**\n     * Change.\n     * @param {object} input The input that was changed.\n     */\n    change(input) {\n        const row = input.closest('[data-row]');\n        const cell = input.closest('[data-cell]');\n        const group = input.dataset.group;\n        const value = input.value;\n        const columnid = parseInt(cell.dataset.columnid);\n        const index = parseInt(row.dataset.index);\n        const modules = State.getValue('modules');\n        modules.forEach(module => {\n            // Find the correct cell in the row.\n            const rowIndex = module.rows.findIndex(r => r.id == index);\n            if (rowIndex === -1) {\n                return;\n            }\n            const cellIndex = module.rows[rowIndex].cells.findIndex(c => c.columnid == columnid);\n            const cell = module.rows[rowIndex].cells[cellIndex];\n            cell.value = value ? value : null;\n            if (input.dataset.height) {\n                cell.height = input.dataset.height;\n            }\n            // Find the other cells with the same group and null the value.\n            if (group) {\n                module.rows[rowIndex].cells.forEach(c => {\n                    if (c.group === group && c.columnid !== columnid && c.value !== null) {\n                        c.value = null;\n                    }\n                });\n            }\n            if (cell.type == 'select') {\n                // Find the option that matches the value and set it as selected.\n                cell.options.forEach(option => {\n                    option.selected = (option.name === value);\n                });\n            }\n        });\n        this.markchanges();\n        this.sumtotals();\n        State.setValue('modules', modules);\n    }\n\n    /**\n     * Markchanges.\n     * Mark the cells that have changed.\n     */\n    markchanges() {\n        const modules = State.getValue('modules');\n        modules.forEach(module => {\n            module.rows.forEach(row => {\n                row.cells.forEach(cell => {\n                    cell.changed = cell.value != cell.oldvalue;\n                });\n            });\n        });\n        State.setValue('modules', modules);\n    }\n\n    /**\n     * Sumtotals.\n     * Sum all columns.\n     */\n    sumtotals() {\n        const columnsData = State.getValue('columns');\n        // Reset the sum for all columns.\n        columnsData.forEach(column => {\n            column.sum = 0;\n            column.newsum = 0;\n            column.hasnewsum = false;\n            column.changed = false;\n        });\n        const modules = State.getValue('modules');\n        let overaltotals = 0;\n        let newsumtotals = 0;\n        modules.forEach(module => {\n            module.rows.forEach(row => {\n                row.cells.forEach(cell => {\n                    if (cell.type === 'number' || cell.type === 'float') {\n                        const column = columnsData.find(c => c.columnid === cell.columnid);\n                        if (column) {\n                            if (cell.changed) {\n                                column.sum = (parseFloat(column.sum) || 0) + parseFloat(cell.oldvalue);\n                            } else if (cell.value && cell.value !== null) {\n                                column.sum = (parseFloat(column.sum) || 0) + parseFloat(cell.value);\n                            }\n                            if (cell.value) {\n                                column.newsum = (parseFloat(column.newsum) || 0) + parseFloat(cell.value);\n                                column.hasnewsum = true;\n                            }\n                            if (column.sum == 0 && column.newsum > 0) {\n                                column.hasnewsum = true;\n                                column.sum = \" 0\"; // If the sum is 0 and the new sum is greater than 0, set the sum to 0.\n                            }\n                        }\n                        if (cell.changed) {\n                            column.changed = true;\n                        }\n                    }\n                });\n            });\n        });\n        let totalsChanged = false;\n        columnsData.forEach(column => {\n            if (column.type === 'number' || column.type === 'float') {\n                totalsChanged = totalsChanged || column.changed;\n                overaltotals += parseFloat(column.sum) || 0;\n                newsumtotals += parseFloat(column.newsum) || 0;\n            }\n        });\n        columnsData[0].overaltotals = overaltotals;\n        columnsData[0].newsumtotals = newsumtotals;\n        columnsData[0].totalschanged = totalsChanged;\n        State.setValue('columns', columnsData);\n    }\n\n    /**\n     * Change the module name.\n     * @param {object} input The input that was changed.\n     * @return {void}\n     */\n    changeModule(input) {\n        const module = input.closest('[data-region=\"module\"]');\n        const moduleid = module.dataset.id;\n        const name = input.value;\n        const modules = State.getValue('modules');\n        modules.forEach(module => {\n            if (module.moduleid == moduleid) {\n                module.modulename = name;\n            }\n        });\n    }\n\n    /**\n     * Delete a module.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async deleteModule(btn) {\n        const moduleid = btn.closest('[data-region=\"module\"]').dataset.id;\n        const modules = State.getValue('modules');\n        const moduleIndex = modules.findIndex(m => m.moduleid == moduleid);\n        if (moduleIndex !== -1) {\n            // Add the deleted attribute to the module.\n            modules[moduleIndex].deleted = true;\n            modules[moduleIndex].rows.forEach(row => {\n                row.deleted = true; // Mark all rows as deleted.\n                row.cells.forEach(cell => {\n                    if (cell.value !== null && (cell.type == 'float' || cell.type == 'number')) {\n                        cell.changed = true;\n                        cell.value = null; // Clear the value.\n                    }\n                });\n            });\n            State.setValue('modules', modules);\n        }\n    }\n\n    /**\n     * Create a new module.\n     * @return {Integer} The module id.\n     */\n    createModule() {\n        this.moduleNumber = this.moduleNumber - 1;\n        return this.moduleNumber;\n    }\n\n    /**\n     * Add a new module.\n     * @return {void}\n     */\n    addModule() {\n        const modules = State.getValue('modules');\n        const moduleid = this.createModule();\n        const row = this.createRow();\n        const module = {\n            moduleid: moduleid,\n            modulename: ' ',\n            deleted: false,\n            editor: true,\n            rows: [row],\n        };\n        modules.push(module);\n        this.resetRowSortorder();\n        State.setValue('modules', modules);\n    }\n\n    /**\n     * Get the row from the state.\n     * @param {int} rowid The rowid.\n     */\n    getRow(rowid) {\n        const modules = State.getValue('modules');\n        // Combine all rows in one array.\n        const rows = modules.reduce((acc, module) => {\n            return acc.concat(module.rows);\n        }, []);\n        const row = rows.find(r => r.id == rowid);\n        return row;\n    }\n\n    /**\n     * Move a row within a module to a new position, based on previd.\n     * @param {Number} moduleId The module to update.\n     * @param {Number} rowId The row to move.\n     * @param {Number|null} prevRowId The row after which the moved row should appear. Null means move to top.\n     */\n    moveRow(moduleId, rowId, prevRowId) {\n        const modules = State.getValue('modules');\n        const module = modules.find(m => m.moduleid === moduleId);\n        if (!module) {\n            return;\n        }\n\n        const rows = module.rows;\n        const rowIndex = rows.findIndex(r => r.id === rowId);\n        if (rowIndex === -1) {\n            return;\n        }\n\n        // Remove the row from its current position\n        const [rowToMove] = rows.splice(rowIndex, 1);\n\n        // Find index to insert after\n        let insertIndex = 0;\n        if (prevRowId !== null) {\n            const prevIndex = rows.findIndex(r => r.id === prevRowId);\n            insertIndex = prevIndex + 1;\n        }\n\n        // Insert the row\n        rows.splice(insertIndex, 0, rowToMove);\n\n        // Reset sortorders\n        rows.forEach((row, index) => {\n            row.sortorder = index + 1;\n        });\n\n        // Update the state\n        State.setValue('modules', modules);\n    }\n\n    /**\n     * Reset the row sortorder values.\n     * @return {void}\n     */\n    resetRowSortorder() {\n        const modules = State.getValue('modules');\n        modules.forEach((module, mindex) => {\n            module.modulesortorder = mindex;\n            module.rows.forEach((row, index) => {\n                row.sortorder = index;\n            });\n        });\n        State.setValue('modules', modules);\n    }\n\n    /**\n     * Show the changes.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async showchanges(btn) {\n        // Remove the active class from all buttons.\n        const tds = document.querySelectorAll('[data-action=\"showchanges\"]');\n        tds.forEach(td => {\n            if (td !== btn) {\n                td.classList.remove('active');\n            }\n        });\n        // Add the active class to the clicked button.\n        btn.classList.add('active');\n    }\n\n    /**\n     * Close the changes.\n     * @return {void}\n     */\n    async closeChanges() {\n        // Remove the active class from all buttons.\n        const tds = document.querySelectorAll('[data-action=\"showchanges\"]');\n        tds.forEach(td => {\n            td.classList.remove('active');\n        });\n    }\n\n    /**\n     * Accept the RFC.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async acceptRfc(btn) {\n        const userid = btn.closest('[data-rfc]').dataset.userid;\n        const response = await Repository.acceptRfc({datafieldid: this.datafieldid, userid: userid});\n        if (response) {\n            await this.getTableData();\n            const update = await Repository.getData({datafieldid: this.datafieldid, showrfc: 0});\n            const modulesStatic = this.parseModules(update);\n            State.setValue('modulesstatic', modulesStatic);\n        }\n    }\n\n    /**\n     * Reject the RFC.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async rejectRfc(btn) {\n        const pending = new Pending('customfield_sprogramme/manager:rejectRFC');\n        const userid = btn.closest('[data-rfc]').dataset.userid;\n        const response = await Repository.cancelRfc({datafieldid: this.datafieldid, userid: userid});\n        if (response) {\n            await this.getTableData();\n        }\n        pending.resolve();\n    }\n\n    /**\n     * Submit the RFC for approval.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async submitRfc(btn) {\n        const pending = new Pending('customfield_sprogramme/manager:submitRFC');\n        const userid = btn.closest('[data-rfc]').dataset.userid;\n        const response = await Repository.submitRfc({datafieldid: this.datafieldid, userid: userid});\n        if (response) {\n            await this.getTableData();\n        }\n        pending.resolve();\n    }\n\n    /**\n     * Cancel the RFC.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async cancelRfc(btn) {\n        const pending = new Pending('customfield_sprogramme/manager:cancelRFC');\n        const userid = btn.closest('[data-rfc]').dataset.userid;\n        const response = await Repository.cancelRfc({datafieldid: this.datafieldid, userid: userid});\n        if (response) {\n            await this.getTableData();\n        }\n        pending.resolve();\n    }\n\n    /**\n     * Remove the RFC.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async removeRfc(btn) {\n        const pending = new Pending('customfield_sprogramme/manager:removeRFC');\n        const userid = btn.closest('[data-rfc]').dataset.userid;\n        const response = await Repository.removeRfc({datafieldid: this.datafieldid, userid: userid});\n        if (response) {\n            await this.getTableData();\n        }\n        pending.resolve();\n    }\n\n    /**\n     * Reset the table to the original state.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async resetRfc(btn) {\n        const form = document.querySelector('[data-region=\"app\"]');\n        const changeCells = form.querySelectorAll('[data-action=\"showchanges\"]');\n        changeCells.forEach(cell => {\n            const input = cell.querySelector('[data-input=\"rfc\"]');\n            if (input) {\n                input.dataset.input = 'auto';\n                input.value = input.dataset.oldvalue;\n                input.dataset.rfcstate = '0';\n                cell.classList.remove('rfc');\n            }\n        });\n        this.sumtotals();\n        btn.classList.add('d-none');\n    }\n\n    /**\n     * Augment the table with additional data.\n     * @param {object} btn The button that was clicked.\n     * @return {void}\n     */\n    async augmentTable(btn) {\n        const modules = State.getValue('modules');\n        modules.forEach(module => {\n            module.rows.forEach(row => {\n                row.cells.forEach(cell => {\n                    if (cell.oldvalue != cell.value) {\n                        cell.changes = {\n                            oldvalue: cell.oldvalue ? cell.oldvalue : '0',\n                            newvalue: cell.value,\n                        };\n                        cell.changed = true;\n                    } else {\n                        cell.changes = null;\n                        cell.changed = false;\n                    }\n                });\n            });\n        });\n        State.setValue('modules', modules);\n        // Add the augment class to the button.\n        btn.classList.add('active');\n    }\n\n    /**\n     * Send a closeform custom event.\n     * @return {void}\n     */\n    async closeForm() {\n        // Check if there are unsaved changes.\n        const modules = State.getValue('modules');\n        const rfc = State.getValue('rfc');\n        const event = new CustomEvent('closeform', {\n            bubbles: true,\n            composed: true,\n        });\n        if (rfc && rfc.issubmitted) {\n            document.dispatchEvent(event);\n            return;\n        }\n\n        const confirmationStrings = await getStrings([\n            {\n                key: 'confirm',\n                component: 'customfield_sprogramme',\n            },\n            {\n                key: 'unsavedchanges',\n                component: 'customfield_sprogramme',\n            },\n            {\n                key: 'closewithoutsaving',\n                component: 'customfield_sprogramme',\n            },\n            {\n                key: 'cancel',\n                component: 'customfield_sprogramme',\n            },\n        ]);\n\n        const hasChanges = modules.some(module => module.rows.some(\n            row => row.cells.some(cell => cell.changed || (cell.isnewcell ?? false))\n        ));\n        if (hasChanges) {\n            Notification.confirm(\n                ...confirmationStrings,\n                () => {\n                    document.dispatchEvent(event);\n                },\n                () => {\n                    // Do nothing, the user cancelled the action.\n                },\n            );\n            return;\n        } else {\n            document.dispatchEvent(event);\n        }\n    }\n\n    /**\n     * Download the table as a CSV file.\n     * @return {void}\n     */\n    async downloadCsv() {\n        const csv = await Repository.csvData({datafieldid: this.datafieldid});\n        const blob = new Blob([csv.csv], {type: 'text/csv'});\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = csv.filename;\n        a.click();\n        window.URL.revokeObjectURL(url);\n    }\n\n    /**\n     * Navigate to the next or previous row and left or right column.\n     * @param {Event} e The event.\n     * @return {void}\n     */\n    navigate(e) {\n        const currentIndex = e.target.closest('[data-row]').dataset.index;\n        const currentColumn = e.target.closest('[data-cell]').dataset.columnid;\n        const allRows = document.querySelectorAll('[data-row]');\n        for (let i = 0; i < allRows.length; i++) {\n            if (allRows[i].dataset.index == currentIndex) {\n                if (e.key === 'ArrowDown' && i < allRows.length - 1) {\n                    const nextInput = allRows[i + 1].querySelector(`[data-columnid=\"${currentColumn}\"] input`);\n                    if (nextInput) {\n                        nextInput.focus();\n                    }\n                }\n                if (e.key === 'ArrowUp' && i > 0) {\n                    const previousInput = allRows[i - 1].querySelector(`[data-columnid=\"${currentColumn}\"] input`);\n                    if (previousInput) {\n                        previousInput.focus();\n                    }\n                }\n            }\n        }\n        // This part is not working yet, it might not be accessible.\n        if (e.key === 'ArrowRight') {\n            const nextColumn = e.target.closest('[data-cell]').nextElementSibling;\n            if (nextColumn) {\n                nextColumn.focus();\n            }\n        }\n        if (e.key === 'ArrowLeft') {\n            const previousColumn = e.target.closest('[data-cell]').previousElementSibling;\n            if (previousColumn) {\n                previousColumn.focus();\n            }\n        }\n    }\n}\n\n/*\n * Initialise\n * @param {HTMLElement} element The element.\n * @param {String} datafieldid The datafieldid\n * @return {Manager} The manager instance.\n */\nconst init = (element, datafieldid) => {\n    componentInit();\n    return new Manager(element, datafieldid);\n};\n\nexport default {\n    init: init,\n};\n"],"names":["Manager","constructor","element","datafieldid","parseInt","addEventListeners","getTableData","document","addEventListener","e","btn","target","closest","preventDefault","actions","dataset","action","form","querySelector","input","change","modulename","changeModule","tagName","textarea","style","height","scrollHeight","key","navigate","dragging","handle","dataTransfer","effectAllowed","parentNode","region","rect","getBoundingClientRect","clientY","top","insertBefore","nextSibling","rowId","index","prevRowId","previousElementSibling","moduleId","id","moveRow","response","Repository","getData","this","showrfc","modules","length","parseModules","columns","setValue","rfc","canedit","sumtotals","getColumns","addModule","error","exception","forEach","mod","editor","rows","map","row","cells","cell","column","find","Object","assign","type","options","option","clonedOption","name","value","selected","changed","oldvalue","getRowObject","checkCellValue","substring","cleanCell","cellKeys","cleaned","cleanList","items","allowedKeys","item","validateModules","State","getValue","result","module","trim","deleted","checkRow","groups","group","push","keys","cleanModules","rowSpec","moduleid","modulesortorder","sortorder","disciplines","competencies","pending","Pending","async","saveConfirmButton","classList","add","resolve","cleanedModules","setData","update","modulesStatic","setTimeout","remove","set","actionMap","addRow","deleteRow","deleteModule","setTableData","showchanges","closeChanges","acceptRfc","rejectRfc","submitRfc","cancelRfc","removeRfc","resetRfc","closeForm","downloadCsv","augmentTable","call","rowid","m","createRow","splice","indexOf","r","resetRowSortorder","rowNumber","structuredClone","isnewcell","modulefound","rowIndex","findIndex","columnid","cellIndex","c","markchanges","columnsData","sum","newsum","hasnewsum","overaltotals","newsumtotals","parseFloat","totalsChanged","totalschanged","moduleIndex","createModule","moduleNumber","getRow","reduce","acc","concat","rowToMove","insertIndex","mindex","querySelectorAll","td","userid","rfcstate","changes","newvalue","event","CustomEvent","bubbles","composed","issubmitted","dispatchEvent","confirmationStrings","component","some","confirm","csv","csvData","blob","Blob","url","window","URL","createObjectURL","a","createElement","href","download","filename","click","revokeObjectURL","currentIndex","currentColumn","allRows","i","nextInput","focus","previousInput","nextColumn","nextElementSibling","previousColumn","init"],"mappings":"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"}